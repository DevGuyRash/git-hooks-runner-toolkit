{
  "id": "snapshot_1761197463703_az2s3ovon",
  "approvalId": "approval_1761197463700_sjf527tau",
  "approvalTitle": "pre-commit-configured-actions requirements",
  "version": 1,
  "timestamp": "2025-10-23T05:31:03.703Z",
  "trigger": "initial",
  "status": "pending",
  "content": "## Introduction\n\nDeliver a POSIX-compliant example hook that runs configurable actions before commits, while consolidating example configuration files into per-hook `config/` directories so the toolkit remains predictable across ephemeral and persistent installs. The update must preserve existing post-merge behaviour and provide a migration path for legacy config locations.\n\n## Alignment with Product Vision\n\nSupports the toolkit goal of reusable, composable hooks by giving teams symmetry between pre- and post-commit automation and establishing clear conventions for shipping example configuration assets.\n\n## Requirements\n\n### Requirement 1\n\n**User Story:** As a repository maintainer, I want a `pre-commit` example that evaluates staged changes via configurable rules, so that contributors receive immediate feedback before creating commits.\n\n#### Acceptance Criteria\n\n1. WHEN the example script runs during `pre-commit` THEN it SHALL inspect only staged changes and execute matching configured commands.\n2. IF no rules match staged changes THEN the script SHALL exit 0 without emitting spurious logs.\n3. WHEN a configured command exits non-zero AND `continue_on_error` is false THEN the script SHALL stop and propagate the failure code to Git.\n\n### Requirement 2\n\n**User Story:** As an installer of example hooks, I want config files to live alongside the staged hook parts, so that installs remain self-contained regardless of ephemeral or persistent mode.\n\n#### Acceptance Criteria\n\n1. WHEN `install.sh stage add examples` copies a hook that ships config files THEN the config SHALL be installed under `{hook}.d/config/`.\n2. IF an example hook seeks configuration THEN it SHALL first search its colocated `config/` directory before falling back to legacy paths.\n3. WHEN a legacy config path is used THEN the hook SHALL emit a deprecation notice encouraging migration, without failing execution.\n\n### Requirement 3\n\n**User Story:** As a maintainer of the toolkit, I want automated coverage for the new behaviours, so that regressions in staging logic or hook execution are caught early.\n\n#### Acceptance Criteria\n\n1. WHEN running the example test suite THEN scenarios SHALL exist that cover the new pre-commit example success and failure paths.\n2. WHEN staging examples in ephemeral mode within tests THEN configs SHALL remain inside the hook directory and be cleaned up automatically.\n3. IF the legacy post-merge example is staged and executed THEN existing tests SHALL continue to pass.\n\n## Non-Functional Requirements\n\n### Code Architecture and Modularity\n- **Single Responsibility Principle:** Shared watch logic SHALL live in a reusable helper, with thin hook-specific entrypoints.\n- **Modular Design:** Hook scripts SHALL compose helper functions without duplicating diff or config parsing logic.\n- **Dependency Management:** All scripts SHALL rely only on POSIX shell and existing toolkit helpers.\n- **Clear Interfaces:** Helper APIs SHALL expose explicit functions for config discovery and change enumeration.\n\n### Performance\n- Pre-commit hook SHALL avoid extra Git commands beyond what is required to list staged changes, keeping runtime under ~1s on small repos.\n\n### Security\n- Scripts SHALL avoid executing untrusted commands unless supplied through vetted configuration entries and SHALL escape user data where logged.\n\n### Reliability\n- Hooks SHALL handle missing optional dependencies (`jq`/`yq`) gracefully and log informative warnings.\n\n### Usability\n- Hooks SHALL display actionable log messages, including clear indicators when reading configs from legacy locations.\n",
  "fileStats": {
    "size": 3596,
    "lines": 60,
    "lastModified": "2025-10-23T05:30:46.745Z"
  },
  "comments": []
}